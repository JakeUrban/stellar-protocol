## Preamble

```
SEP: 0010
Title: Stellar Web Authentication
Author: Sergey Nebolsin <@nebolsin>, Tom Quisel <tom.quisel@gmail.com>, Leigh McCulloch <@leighmcculloch>, Jake Urban <jake@stellar.org>
Status: Active
Created: 2018-07-31
Updated: 2021-02-10
Version 3.1.1
```

## Simple Summary

This SEP defines the standard way for clients such as wallets or exchanges to create authenticated web sessions on behalf of a user who holds a Stellar account. A wallet may want to authenticate with any web service which requires a Stellar account ownership verification, for example, to upload KYC information to an anchor in an authenticated way as described in [SEP-12](sep-0012.md).

## Abstract

This protocol is a variation of mutual challenge-response, which uses Stellar transactions to encode challenges and responses.

It involves three components:
- A **Home Domain**: a domain hosting a [SEP-1 stellar.toml](sep-0001.md) containing a `WEB_AUTH_ENDPOINT` (URL) and `SIGNING_KEY` (`G...`).
- A **Web Auth Endpoint**: an endpoint providing the GET and POST operations discussed in this document. The endpoint may be hosted on the **Home Domain**, a sub-domain of the **Home Domain**, or any other domain.
- An **Authenticating Account**: The public key of the Stellar account being authenticated.
- The **Client Application**: the application used by the account holder of the **Authenticating Account**.

The discovery flow is as follows:

1. The **Client Application** retrieves the `stellar.toml` from the **Home Domain** in accordance with [SEP-1 stellar.toml](sep-0001.md).
1. The **Client Application** looks up the `WEB_AUTH_ENDPOINT` and `SIGNING_KEY` from the `stellar.toml`.

The authentication flow is as follows:

1. The **Client Application** obtains a unique [`challenge`](#challenge) from the **Web Auth Endpoint**, which is represented as specially formed Stellar transaction
1. The **Client Application** verifies that the transaction has an invalid sequence number 0.  This is extremely important to ensure the transaction isn't malicious.
1. The **Client Application** verifies that the transaction is signed by the `SIGNING_KEY` obtained through discovery flow.
1. The **Client Application** verifies that the transaction's first operation is a Manage Data operation that has its:
   1. Source account set to the **Authenticating Account**
   1. Key set to `<home domain> auth` where the home domain is the **Home Domain**.
   1. Value set to a nonce value.
1. The **Client Application** verifies that if the transaction has a Manage Data operation with key `web_auth_domain` that it has:
   1. Source account set to the ``SIGNING_KEY`` from the **Home Domain**'s [SEP-1 stellar.toml](sep-0001.md).
   1. Value set to the **Web Auth Endpoint**'s domain.
1. The **Client Application** verifies that if the transaction has other operations they are Manage Data operations that all have their source accounts set to the the ``SIGNING_KEY`` from the **Home Domain**'s [SEP-1 stellar.toml](sep-0001.md).
1. The **Client Application** signs the transaction using the secret key(s) of the signer(s) for the **Authenticating Account**
1. The **Client Application** submits the signed challenge back to the **Web Auth Endpoint** using [`token`](#token) endpoint
1. The **Web Auth Endpoint** checks that the **Authenticating Account** exists
1. If the **Authenticating Account** exists:
  1. The **Web Auth Endpoint** gets the signers of the **Authenticating Account**
  1. The **Web Auth Endpoint** verifies that one or more signatures are from signers of the **Authenticating Account**.
  1. The **Web Auth Endpoint** verifies that there is only one additional signature from the ``SIGNING_KEY`` on the **Home Domain**'s [SEP-1 stellar.toml](sep-0001.md).
  1. The **Web Auth Endpoint** verifies the weight provided by the signers of the **Authenticating Account** meets the required threshold(s), if any
1. If the **Authenticating Account** does not exist (optional):
  1. The **Web Auth Endpoint** verifies the signature count is two
  1. The **Web Auth Endpoint** verifies that one signature is correct for the master key of the **Authenticating Account**
  1. The **Web Auth Endpoint** verified that the other signature is from the ``SIGNING_KEY`` on the **Home Domain**'s [SEP-1 stellar.toml](sep-0001.md).
1. If the signatures check out, the **Web Auth Endpoint** responds with a [JWT](https://jwt.io) that represents the authenticated session

The flow achieves several things:

* Both **Client Application** and **Web Auth Endpoint** can be implemented using well-established Stellar libraries
* The **Client Application** can verify that the **Web Auth Endpoint** holds the secret key to the ``SIGNING_KEY`` from the **Home Domain**'s [SEP-1 stellar.toml](sep-0001.md).
* The **Web Auth Endpoint** can verify that the **Client Application** holds the secret key(s) to signer(s) of the **Authenticating Account**
* The **Web Auth Endpoint** can choose its own timeout for the authenticated session
* The **Web Auth Endpoint** can choose required signing threshold(s) that must be met, if any
* The **Web Auth Endpoint** can choose to include other application-specific claims
* The **Web Auth Endpoint** can choose to authenticate Stellar accounts that do not yet exist

## Authentication Endpoint

The organization with a **Home Domain** indicates that it supports authentication via this protocol by specifying `WEB_AUTH_ENDPOINT` in their [`stellar.toml`](sep-0001.md) file. This is how a wallet knows where to find the **Web Auth Endpoint**. A **Web Auth Endpoint** is required to implement the following behavior for the web authentication endpoint:

* [`GET <WEB_AUTH_ENDPOINT>`](#challenge): request a challenge (step 1)
* [`POST <WEB_AUTH_ENDPOINT>`](#token): exchange a signed challenge for session JWT (step 2)

## Cross-Origin Headers

Valid CORS headers are necessary to allow web clients from other sites to use the endpoints. The following HTTP header must be set for all authentication endpoints, including error responses.

```
Access-Control-Allow-Origin: *
```

In order for browsers-based wallets to validate the CORS headers, as [specified by W3C]( https://www.w3.org/TR/cors/#preflight-request), the preflight request (OPTIONS request) must be implemented in all the endpoints that support Cross-Origin.

### Challenge

This endpoint must respond with a Stellar transaction signed by the ``SIGNING_KEY`` from the **Home Domain**'s [`stellar.toml`](sep-0001.md) file that has an invalid sequence number (0) and thus cannot be executed on the Stellar network. The **Client Application** can then sign the transaction using standard Stellar libraries and submit it to [`token`](#token) endpoint to prove that it controls the **Authenticating Account**. This approach is compatible with hardware wallets such as Ledger. The **Client Application** must also verify the home domain in the first operation of the challenge is the **Home Domain**.

#### Request

```
GET <WEB_AUTH_ENDPOINT>
```

Request Parameters:

Name      | Type          | Description
----------|---------------|------------
`account` | `G...` string | The stellar account that the wallet wishes to authenticate with the **Web Auth Endpoint** 
`home_domain` | string | (optional) a **Home Domain**. Servers that generate tokens for multiple **Home Domain**s can use this parameter to identify which home domain the **Client Application** hopes to authenticate with. If not provided by the **Client Application**, the **Web Auth Endpoint** should assume a default for backwards compatibility with older **Client Applications**.

Example:

```
GET https://auth.example.com/?account=GCIBUCGPOHWMMMFPFTDWBSVHQRT4DIBJ7AD6BZJYDITBK2LCVBYW7HUQ
```

#### Response

On success the endpoint must return `200 OK` HTTP status code and a JSON object with these fields:

* `transaction`: an XDR-encoded Stellar transaction with the following:
  * source account set to the **Home Domain**'s ``SIGNING_KEY``
  * invalid sequence number (set to 0) so the transaction cannot be run on the Stellar network
  * time bounds: `{min: now(), max: now() + 900 }` (we recommend expiration of 15 minutes to give the **Client Application** time to sign transaction)
  * operations:
    * `manage_data(source: authenticating_account, key: '<home domain> auth', value: random_nonce())`
      * The value of key is the **Home Domain**, followed by `auth`. It can be at most 64 characters.
      * The value must be 64 bytes long. It contains a 48 byte cryptographic-quality random string encoded using base64 (for a total of 64 bytes after encoding).
    * subsequent operations, order unimportant:
      * `manage_data(source: server_account, key: 'web_auth_domain', value: web_auth_domain)`
        * The source account is the **Home Domain**'s ``SIGNING_KEY``, the value is the domain of the **Web Auth Endpoint**. It can be at most 64 characters.
      * zero or more `manage_data(source: server_account, ...)` reserved for future use
  * signature by the **Home Domain**'s stellar.toml `SIGNING_KEY`
* `network_passphrase`: (optional but recommended) Stellar network passphrase used by the **Home Domain**. This allows a **Client Application** to verify that it's using the correct passphrase when signing and is useful for identifying when a **Client Application** or **Web Auth Endpoint** have been configured incorrectly.

Example:
```json
{
  "transaction": "AAAAAgAAAADIiRu2BrqqeOcP28PWCkD4D5Rjjsqh71HwvqFX+F4VXAAAAGQAAAAAAAAAAAAAAAEAAAAAXzrUcQAAAABfOtf1AAAAAAAAAAEAAAABAAAAAEEB8rhqNa70RYjaNnF1ARE2CbL50iR9HPXST/fImJN1AAAACgAAADB0aGlzaXNhdGVzdC5zYW5kYm94LmFuY2hvci5hbmNob3Jkb21haW4uY29tIGF1dGgAAAABAAAAQGdGOFlIQm1zaGpEWEY0L0VJUFZucGVlRkxVTDY2V0tKMVBPYXZuUVVBNjBoL09XaC91M2Vvdk54WFJtSTAvQ2UAAAAAAAAAAfheFVwAAABAheKE1HjGnUCNwPbX8mz7CqotShKbA+xM2Hbjl6X0TBpEprVOUVjA6lqMJ1j62vrxn1mF3eJzsLa9s9hRofG3Ag==",
  "network_passphrase": "Public Global Stellar Network ; September 2015"
}
```

You can examine the example challenge transaction in the [XDR Viewer](https://laboratory.stellar.org/#xdr-viewer?input=AAAAAgAAAADIiRu2BrqqeOcP28PWCkD4D5Rjjsqh71HwvqFX%2BF4VXAAAAGQAAAAAAAAAAAAAAAEAAAAAXzrUcQAAAABfOtf1AAAAAAAAAAEAAAABAAAAAEEB8rhqNa70RYjaNnF1ARE2CbL50iR9HPXST%2FfImJN1AAAACgAAADB0aGlzaXNhdGVzdC5zYW5kYm94LmFuY2hvci5hbmNob3Jkb21haW4uY29tIGF1dGgAAAABAAAAQGdGOFlIQm1zaGpEWEY0L0VJUFZucGVlRkxVTDY2V0tKMVBPYXZuUVVBNjBoL09XaC91M2Vvdk54WFJtSTAvQ2UAAAAAAAAAAfheFVwAAABAheKE1HjGnUCNwPbX8mz7CqotShKbA%2BxM2Hbjl6X0TBpEprVOUVjA6lqMJ1j62vrxn1mF3eJzsLa9s9hRofG3Ag%3D%3D&type=TransactionEnvelope)

Every other HTTP status code will be considered an error. For example:

```json
{
   "error": "The provided account has requested too many challenges recently. Try again later."
}
```

### Token

This endpoint accepts a signed challenge transaction, validates it and responds with a session [JSON Web Token](https://jwt.io/) authenticating the account.

The **Client Application** submits a challenge transaction (that was previously returned by the [`challenge`](#challenge) endpoint) as a HTTP POST request to `WEB_AUTH_ENDPOINT` using one of the following formats (both should be equally supported by the server):

* Content-Type: `application/x-www-form-urlencoded`, body: `transaction=<signed XDR (URL-encoded)>`)
* Content-Type: `application/json`, body: `{"transaction": "<signed XDR>"}`

To validate the challenge transaction the following steps are performed by the **Web Auth Endpoint**. If any of the listed steps fail, then the authentication request must be rejected — that is, treated by the **Web Auth Endpoint** as an invalid input.

* decode the received input as a base64-urlencoded XDR representation of Stellar transaction envelope;
* verify that transaction source account is equal to the **Home Domain**'s ``SIGNING_KEY``;
* verify that transaction has time bounds set, and that current time is between the minimum and maximum bounds;
* verify that transaction's first operation is a [Manage Data](https://www.stellar.org/developers/guides/concepts/list-of-operations.html#manage-data) operation that:
  * has a non-null source account
  * has the **Home Domain** as the key of the operation
* verify that transaction envelope has a correct signature by the **Home Domain**'s ``SIGNING_KEY``;
* if the operation's source account exists:
  * verify that the remaining signature count is one or more;
  * verify that remaining signatures on the transaction are signers of the operation's source account;
  * verify that remaining signatures are correct;
  * verify that remaining signatures provide weight that meets the required threshold(s), if any;
* if the operation's source account does not exist:
  * verify that remaining signature count is one;
  * verify that remaining signature is correct for the master key of the **Authenticating Account**
* verify that transaction containing additional Manage Data operations have their source account set to the **Home Domain**'s ``SIGNING_KEY``
* verify that transaction sequenceNumber is equal to zero;

The verification process confirms that the **Client Application** controls the **Authenticating Account**. Depending on your application this may mean complete signing authority, some threshold of control, or being a signer of the account. See [Verification](#verification) for examples.

Upon successful verification, **Web Auth Endpoint** responds with a session JWT, containing the following claims:

* `iss` (the principal that issued a token, [RFC7519, Section 4.1.1](https://tools.ietf.org/html/rfc7519#section-4.1.1)) — a [Uniform Resource Identifier (URI)] for the issuer (`https://example.com` or `https://example.com/G...`)
* `sub` (the principal that is the subject of the JWT, [RFC7519, Section 4.1.2](https://tools.ietf.org/html/rfc7519#section-4.1.2)) — the public key of the authenticating Stellar account (`G...`)
* `iat` (the time at which the JWT was issued [RFC7519, Section 4.1.6](https://tools.ietf.org/html/rfc7519#section-4.1.6)) — current timestamp (`1530644093`)
* `exp` (the expiration time on or after which the JWT must not be accepted for processing, [RFC7519, Section 4.1.4](https://tools.ietf.org/html/rfc7519#section-4.1.4)) — a server can pick its own expiration period for the token (`1530730493`)

The JWT may contain other claims specific to your application, see [RFC7519].

[Uniform Resource Identifier (URI)]: https://en.wikipedia.org/wiki/Uniform_Resource_Identifier
[RFC7519]: https://tools.ietf.org/html/rfc7519

#### Request

```
POST <WEB_AUTH_ENDPOINT>
```

Request Parameters:

Name          | Type   | Description
--------------|--------|------------
`transaction` | string | base64 encoded signed challenge transaction XDR

Example:

```
POST https://auth.example.com/
Content-Type: application/json

{"transaction": "AAAAAgAAAADIiRu2BrqqeOcP28PWCkD4D5Rjjsqh71HwvqFX+F4VXAAAAGQAAAAAAAAAAAAAAAEAAAAAXzrUcQAAAABfOtf1AAAAAAAAAAEAAAABAAAAAEEB8rhqNa70RYjaNnF1ARE2CbL50iR9HPXST/fImJN1AAAACgAAADB0aGlzaXNhdGVzdC5zYW5kYm94LmFuY2hvci5hbmNob3Jkb21haW4uY29tIGF1dGgAAAABAAAAQGdGOFlIQm1zaGpEWEY0L0VJUFZucGVlRkxVTDY2V0tKMVBPYXZuUVVBNjBoL09XaC91M2Vvdk54WFJtSTAvQ2UAAAAAAAAAAvheFVwAAABAheKE1HjGnUCNwPbX8mz7CqotShKbA+xM2Hbjl6X0TBpEprVOUVjA6lqMJ1j62vrxn1mF3eJzsLa9s9hRofG3AsiYk3UAAABArIrkvqmA0V9lIZcVyCUdja6CiwkPwsV8BfI4CZOyR1Oq7ysvNJWwY0G42dpxN9OP1qz4dum8apG2hqvxVWjkDQ=="}
```

You can examine the example signed challenge transaction in the [XDR Viewer](https://laboratory.stellar.org/#xdr-viewer?input=AAAAAgAAAADIiRu2BrqqeOcP28PWCkD4D5Rjjsqh71HwvqFX%2BF4VXAAAAGQAAAAAAAAAAAAAAAEAAAAAXzrUcQAAAABfOtf1AAAAAAAAAAEAAAABAAAAAEEB8rhqNa70RYjaNnF1ARE2CbL50iR9HPXST%2FfImJN1AAAACgAAADB0aGlzaXNhdGVzdC5zYW5kYm94LmFuY2hvci5hbmNob3Jkb21haW4uY29tIGF1dGgAAAABAAAAQGdGOFlIQm1zaGpEWEY0L0VJUFZucGVlRkxVTDY2V0tKMVBPYXZuUVVBNjBoL09XaC91M2Vvdk54WFJtSTAvQ2UAAAAAAAAAAvheFVwAAABAheKE1HjGnUCNwPbX8mz7CqotShKbA%2BxM2Hbjl6X0TBpEprVOUVjA6lqMJ1j62vrxn1mF3eJzsLa9s9hRofG3AsiYk3UAAABArIrkvqmA0V9lIZcVyCUdja6CiwkPwsV8BfI4CZOyR1Oq7ysvNJWwY0G42dpxN9OP1qz4dum8apG2hqvxVWjkDQ%3D%3D&type=TransactionEnvelope)

#### Response

If the **Web Auth Endpoint** successfully validates the submitted challenge transaction, the endpoint should return `200 OK` HTTP status code and a JSON object with the following fields:

Name    | Type   | Description
--------|--------|------------
`token` | string | The JWT that can be used to authenticate future endpoint calls with the anchor

Example:

```json
{
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJHQTZVSVhYUEVXWUZJTE5VSVdBQzM3WTRRUEVaTVFWREpIREtWV0ZaSjJLQ1dVQklVNUlYWk5EQSIsImp0aSI6IjE0NGQzNjdiY2IwZTcyY2FiZmRiZGU2MGVhZTBhZDczM2NjNjVkMmE2NTg3MDgzZGFiM2Q2MTZmODg1MTkwMjQiLCJpc3MiOiJodHRwczovL2ZsYXBweS1iaXJkLWRhcHAuZmlyZWJhc2VhcHAuY29tLyIsImlhdCI6MTUzNDI1Nzk5NCwiZXhwIjoxNTM0MzQ0Mzk0fQ.8nbB83Z6vGBgC1X9r3N6oQCFTBzDiITAfCJasRft0z0"
}
```

Check the example session token on [JWT.IO](https://jwt.io/#debugger-io?token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJHQTZVSVhYUEVXWUZJTE5VSVdBQzM3WTRRUEVaTVFWREpIREtWV0ZaSjJLQ1dVQklVNUlYWk5EQSIsImp0aSI6IjE0NGQzNjdiY2IwZTcyY2FiZmRiZGU2MGVhZTBhZDczM2NjNjVkMmE2NTg3MDgzZGFiM2Q2MTZmODg1MTkwMjQiLCJpc3MiOiJodHRwczovL2ZsYXBweS1iaXJkLWRhcHAuZmlyZWJhc2VhcHAuY29tLyIsImlhdCI6MTUzNDI1Nzk5NCwiZXhwIjoxNTM0MzQ0Mzk0fQ.8nbB83Z6vGBgC1X9r3N6oQCFTBzDiITAfCJasRft0z0).

Every other HTTP status code will be considered an error. For example:

```json
{
   "error": "The provided transaction is not valid"
}
```

## Verification

The verification process confirms that a **Client Application** controls the **Authenticating Account**. Depending on your application this may mean complete signing authority, some threshold of control, or being a signer of the account.

An account's master key may not meet any threshold of control or could have had its weight reduced to zero. Most applications should not assume possession of the master key is possession of an account.

An account's signers may include third-party services providing services to the account holder of the **Authenticating Account**. Authenticating accounts with less than any threshold may allow a third-party to authenticate.

An account's signers may include the **Home Domain**'s ``SIGNING_KEY`` if the server is a signer for the account. When determining the weight of the remaining sigantures the signature from ``SIGNING_KEY`` should be explicitly excluded. A **Web Auth Endpoint** should not assist in authentication.

The **Web Auth Endpoint** should only issue a JWT if the appropriate thresholds are met, but if a **Web Auth Endpoint** is supporting a variety of applications it may choose to use additional application specific claims to capture the threshold of control the **Client Application** has proven.

### Verifying Authority to Move Funds

A **Web Auth Endpoint** that needs to verify that the **Client Application** has authority aligned with the capability to move money out of an **Authenticating Account** can verify that the medium threshold is met. It should do this by checking that the sum of the weights of the challenge transaction signers is equal or greater to the medium threshold.

#### Example

An anchor implementing [SEP-24] will let an authenticated **Client Application** define the destination of withdrawn funds. This level of control is similar to the capability to choose the destination of payments on the network which require a medium threshold.

[SEP-24]: https://github.com/stellar/stellar-protocol/blob/master/ecosystem/sep-0024.md

### Verifying Complete Authority

A **Web Auth Endpoint** that needs to verify the **Client Application** has complete authority of an **Authenticating Account** should verify that the weight of the client signatures meet the high threshold. It should do this by checking that the sum of the weights is equal or greater to the high threshold.

### Verifying Being a Signer

A **Web Auth Endpoint** may choose to issue JWTs for less than all thresholds and based on any other application specific logic. It's important to keep in mind that a Stellar account may have third-parties who are signers. Authenticating accounts with less than any threshold may allow a third-party to authenticate.

### Verifying Accounts that Do Not Exist

A **Web Auth Endpoint** that needs to support validating accounts that do not exist can require a signature of the master key of the account address for accounts that do not exist.

## JWT Expiration

Servers should select an expiration time for the JWT that is appropriate for the assumptions and risk of the interactions the **Client Application** can perform with it. A **Client Application** may be in control of an account at the time the JWT is issued but they may lose control of the account through a change in signers. Expiration times that are too long increase the risk that control on the account has changed. Expiration times that are too short increase the number of times authentication must reoccur, and a user using a hardware signing device or who must complete a complex signing process could have a poor user experience.

## A convention for signatures

Signatures in Stellar involve both the secret key of the signer and the passphrase of the network. SEP-10 clients and servers must use the following convention when deciding what network passphrase to use for signing and verifying signatures in SEP-10:

- If the server is for testing purposes or interacts with the Stellar testnet, use the Stellar testnet passphrase.
- Otherwise, use the Stellar pubnet passphrase.

This convention ensures that SEP-10 clients and servers can use the same passphrase as they're using for interacting with the Stellar network. 

The client can examine the `network_passphrase` (if defined) that the server includes in its response from the challenge endpoint to be sure it's using the correct passphrase and is connecting to the server that it expected.

## JWT best practices

When generating and validating JWTs it's important to follow best practices. The IETF in the process of producing a set of best current practices when using JWTs: [IETF JWT BCP].

[IETF JWT BCP]: https://tools.ietf.org/wg/oauth/draft-ietf-oauth-jwt-bcp/

## Implementations

* iOS and macOS SDK: https://github.com/Soneso/stellar-ios-mac-sdk/blob/master/README.md#8-stellar-web-authentication
